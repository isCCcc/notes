> -- 二叉树 - easy
> [点击直达力扣](https://leetcode.cn/problems/merge-two-binary-trees/description/)

## 说明
    给你两棵二叉树： root1 和 root2 。
    
    想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
    
    返回合并后的二叉树。
    
    注意: 合并过程必须从两个树的根节点开始。

 

示例 1：

    输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
    输出：[3,4,5,5,4,null,7]

示例 2：

    输入：root1 = [1], root2 = [1,2]
    输出：[2,2]

## 解法

> 若有一个节点为空，则返回 r1 和 r2 中不为空的节点
> 
> 若两个节点都不为空，则直接操作 r1，修改 r1 的 value
> 
> 同时递归 r1 和 r2 的后代子树，重复上述过程

```ts
// 直接修改root1并返回
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
    if (!root1) { return root2 }
    if (!root2) { return root1 }
    root1.val += root2.val
    root1.left = mergeTrees(root1.left, root2.left)
    root1.right = mergeTrees(root1.right, root2.right)
    return root1
};

// 构建一颗新的二叉树
// function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
//     if (!root1 && !root2) { return null }
//     else if (!root1 && root2) { return root2 }
//     else if (root1 && !root2) { return root1 }
//     let root = new TreeNode(root1.val + root2.val)
//     root.left = mergeTrees(root1.left, root2.left)
//     root.right = mergeTrees(root1.right, root2.right)
//     return root
// };
```